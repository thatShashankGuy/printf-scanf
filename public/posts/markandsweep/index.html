<!doctype html>





































<html
  class="not-ready lg:text-base"
  style="--bg: #faf8f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>Garbage Collection in JavaScript - Printf/Scanf</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="What is Garbage Collection? Unlike low-level languages like C, where memory management (allocation and freeing of memory) is handled by developers, high-level languages like JavaScript manage memory automatically. JavaScript abstracts the key concepts of allocating and freeing memory by implementing various algorithms.
The process of identifying memory that has been allocated but is no longer required by the program, referred to as garbage, is known as garbage collection.
Garbage Collection Algorithms There are many garbage collection algorithms, such as Mark and Sweep, Reference Counting, Generational Garbage Collection, and Mark-Compact, among others." />
  <meta name="author" content="Shashank Shekhar" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://printf-scanf.pages.dev/main.min.css" />

  
  
  
  
  
  <link rel="preload" as="image" href="https://printf-scanf.pages.dev/theme.png" />

  
  
  
  
  

  
  
  <link rel="preload" as="image" href="https://printf-scanf.pages.dev/github.svg" />
  
  <link rel="preload" as="image" href="https://printf-scanf.pages.dev/linkedin.svg" />
  
  <link rel="preload" as="image" href="https://printf-scanf.pages.dev/rss.svg" />
  
  

  
  
  <script
    defer
    src="https://printf-scanf.pages.dev/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  

  
  <link rel="icon" href="https://printf-scanf.pages.dev/fav.png" />
  <link rel="apple-touch-icon" href="https://printf-scanf.pages.dev/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.126.1">

  
  
  
  
  


  
  
  <meta itemprop="name" content="Garbage Collection in JavaScript">
  <meta itemprop="description" content="What is Garbage Collection? Unlike low-level languages like C, where memory management (allocation and freeing of memory) is handled by developers, high-level languages like JavaScript manage memory automatically. JavaScript abstracts the key concepts of allocating and freeing memory by implementing various algorithms.
The process of identifying memory that has been allocated but is no longer required by the program, referred to as garbage, is known as garbage collection.
Garbage Collection Algorithms There are many garbage collection algorithms, such as Mark and Sweep, Reference Counting, Generational Garbage Collection, and Mark-Compact, among others.">
  <meta itemprop="datePublished" content="2024-08-10T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-08-10T00:00:00+00:00">
  <meta itemprop="wordCount" content="946">
  
  <meta property="og:url" content="https://printf-scanf.pages.dev/posts/markandsweep/">
  <meta property="og:site_name" content="Printf/Scanf">
  <meta property="og:title" content="Garbage Collection in JavaScript">
  <meta property="og:description" content="What is Garbage Collection? Unlike low-level languages like C, where memory management (allocation and freeing of memory) is handled by developers, high-level languages like JavaScript manage memory automatically. JavaScript abstracts the key concepts of allocating and freeing memory by implementing various algorithms.
The process of identifying memory that has been allocated but is no longer required by the program, referred to as garbage, is known as garbage collection.
Garbage Collection Algorithms There are many garbage collection algorithms, such as Mark and Sweep, Reference Counting, Generational Garbage Collection, and Mark-Compact, among others.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-08-10T00:00:00+00:00">

  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Garbage Collection in JavaScript">
  <meta name="twitter:description" content="What is Garbage Collection? Unlike low-level languages like C, where memory management (allocation and freeing of memory) is handled by developers, high-level languages like JavaScript manage memory automatically. JavaScript abstracts the key concepts of allocating and freeing memory by implementing various algorithms.
The process of identifying memory that has been allocated but is no longer required by the program, referred to as garbage, is known as garbage collection.
Garbage Collection Algorithms There are many garbage collection algorithms, such as Mark and Sweep, Reference Counting, Generational Garbage Collection, and Mark-Compact, among others.">

  
  
  
  <link rel="canonical" href="https://printf-scanf.pages.dev/posts/markandsweep/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="https://printf-scanf.pages.dev/"
      >Printf/Scanf</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    
    <nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6">
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/about/"
        >About Me</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/notice_board/"
        >Notice</a
      >
      
    </nav>
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/https://github.com/thatShashankGuy"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./linkedin.svg)"
        href="https://linkedin.com/in/https://www.linkedin.com/in/thatshashanguy/"
        target="_blank"
        rel="me"
      >
        linkedin
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href="https://printf-scanf.pages.dev/index.xml"
        target="_blank"
        rel="alternate"
      >
        rss
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">Garbage Collection in JavaScript</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Aug 10, 2024</time>
      
      
      
      
      <span class="mx-1">&middot;</span>
      <span>Shashank Shekhar</span>
      
    </div>
    
  </header>

  <section><p><img src="/js.svg" alt="JS Image" title="js"></p>
<h4 id="what-is-garbage-collection">What is Garbage Collection?</h4>
<p>Unlike low-level languages like C, where memory management (allocation and freeing of memory) is handled by developers, high-level languages like JavaScript manage memory automatically. JavaScript abstracts the key concepts of allocating and freeing memory by implementing various algorithms.</p>
<p>The process of identifying memory that has been allocated but is no longer required by the program, referred to as <em>garbage</em>, is known as <em>garbage collection</em>.</p>
<h4 id="garbage-collection-algorithms">Garbage Collection Algorithms</h4>
<p>There are many garbage collection algorithms, such as <em>Mark and Sweep</em>, <em>Reference Counting</em>, <em>Generational Garbage Collection</em>, and <em>Mark-Compact</em>, among others.</p>
<p>We will focus on the <em>Mark and Sweep</em> algorithm because it is the most widely used garbage collection method in JavaScript engines, including those used in browsers and Node.js.</p>
<p>Before diving into <em>Mark and Sweep</em>, let&rsquo;s briefly touch on its predecessor, the <em>Reference Counting</em> algorithm.</p>
<h4 id="reference-counting-algorithm">Reference Counting Algorithm</h4>
<p>The core concept of garbage collection algorithms is the notion of references. In memory management, an object is said to reference another object if it can access the latter (either implicitly or explicitly).</p>
<p>A JavaScript object implicitly references its prototype, while it explicitly references the value of one of its properties.</p>
<p>This algorithm simplifies the problem from determining whether an object is still needed to determining if an object still has other objects referencing it. An object is considered &ldquo;garbage,&rdquo; or collectible, if there are zero references pointing to it.</p>
<p>Let&rsquo;s try to understand this with some code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">JSObject</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">refCount</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Starting with a reference count of 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">one</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">JSObject</span>(<span style="color:#e6db74">&#34;one&#34;</span>); <span style="color:#75715e">// Reference to JSObject - refCount is 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">two</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">one</span>; <span style="color:#75715e">// Adding another reference to one - refCount is 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">three</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">one</span>; <span style="color:#75715e">// Adding another reference to one - refCount is 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Removing references to the object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">three</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// refCount reduces to 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">two</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// refCount reduces to 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// As one is still referencing JSObject, it cannot be collected
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">one</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// refCount reduces to 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// With no references to JSObject, it can now be marked as garbage.
</span></span></span></code></pre></div><h4 id="limitation-of-reference-counting-circular-references">Limitation of Reference Counting: Circular References</h4>
<p>A key limitation of reference counting is its inability to handle cyclic references. A circular reference occurs when two objects reference each other.</p>
<p>Let’s tweak our code to demonstrate this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">JSObject</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">refCount</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Starting with a reference count of 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Creating two new objects with reference count 1 each
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">one</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">JSObject</span>(<span style="color:#e6db74">&#34;One&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">two</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">JSObject</span>(<span style="color:#e6db74">&#34;Two&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Both objects add a reference to each other; refCount of both is incremented by 1, making refCount 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">one</span>.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">two</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">two</span>.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">one</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">one</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">two</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Even after removing external references to both objects/nodes, their refCounts remain at 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The garbage collector won&#39;t collect these objects due to the circular reference.
</span></span></span></code></pre></div><h4 id="mark-and-sweep-algorithm">Mark and Sweep Algorithm</h4>
<p>The <em>Mark and Sweep</em> algorithm redefines &ldquo;an object is no longer needed&rdquo; as &ldquo;an object is unreachable.&rdquo;</p>
<p>The algorithm works by assuming knowledge of a set of objects called <em>roots</em>. In JavaScript, <em>global objects</em> are considered roots.</p>
<p>Periodically, the garbage collector starts from these roots, finds all objects that are referenced from these roots, then finds all objects referenced from those objects, and so on.</p>
<p>All the objects found by the garbage collector are called <em>reachable objects</em>, while the rest are considered <em>unreachable objects</em>.</p>
<p>The algorithm then <em>marks</em> the reachable objects and collects or <em>sweeps</em> the unreachable (unmarked) objects.</p>
<p>Here is a descriptive diagram to understand the algorithm:</p>
<p><img src="/marksweep.png" alt="Mark and Sweep Image" title="mark and sweep"></p>
<p>An advantage of <em>Mark and Sweep</em> over reference counting is that circular references are not an issue because only objects not referenced by global objects are collected.</p>
<h4 id="implementation-of-mark-and-sweep">Implementation of Mark and Sweep</h4>
<p>Here is a basic example of the <em>Mark and Sweep</em> algorithm. I’ve used an imaginary <em>heap</em> and <em>roots</em> to demonstrate how JavaScript works with the actual ones.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">marked</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">ref</span> <span style="color:#f92672">=</span> []; <span style="color:#75715e">// To hold references to other nodes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">addRef</span>(<span style="color:#a6e22e">node</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">ref</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">node</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MarkAndSweepGC</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span> <span style="color:#f92672">=</span> []; <span style="color:#75715e">// Imaginary heap for demo purposes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">roots</span> <span style="color:#f92672">=</span> []; <span style="color:#75715e">// JS global variables (roots)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">createObject</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Node</span>(<span style="color:#a6e22e">name</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">node</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">addRoot</span>(<span style="color:#a6e22e">node</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">roots</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">node</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">mark</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Mark all reachable objects
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">traverse</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">node</span>) =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">marked</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">marked</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">ref</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">ref</span>) =&gt; <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">ref</span>));
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">roots</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">root</span>) =&gt; <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span>));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sweep</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Sweep unmarked objects
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>.<span style="color:#a6e22e">filter</span>((<span style="color:#a6e22e">node</span>) =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">marked</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`Collecting </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">marked</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>; <span style="color:#75715e">// Reset marked for the next GC cycle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">runGC</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Running garbage collection...&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">mark</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">sweep</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Garbage collection complete.&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// USAGE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">gc</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MarkAndSweepGC</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Create objects
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">objA</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">createObject</span>(<span style="color:#e6db74">&#34;A&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">objB</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">createObject</span>(<span style="color:#e6db74">&#34;B&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">objC</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">createObject</span>(<span style="color:#e6db74">&#34;C&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Set up references (A -&gt; B, B -&gt; C)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">objA</span>.<span style="color:#a6e22e">addRef</span>(<span style="color:#a6e22e">objB</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">objB</span>.<span style="color:#a6e22e">addRef</span>(<span style="color:#a6e22e">objC</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Add roots (consider objA as a root object)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">addRoot</span>(<span style="color:#a6e22e">objA</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Run the garbage collector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">runGC</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Now, remove the root reference to objA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">roots</span> <span style="color:#f92672">=</span> [];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Run the garbage collector again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">gc</span>.<span style="color:#a6e22e">runGC</span>();
</span></span></code></pre></div><h4 id="conclusion">Conclusion</h4>
<p>Garbage collection handles the freeing of allocated memory, but memory management also includes tasks like manually allocating memory to the heap and analyzing memory usage. We will discuss these topics in detail in future posts.</p>
<p>I hope you now have a better understanding of how JavaScript manages the memory you allocate while writing your code.</p>
<p>Thank you for reading, and happy coding! Cheers!!!</p>
<h4 id="further-reading">Further Reading:</h4>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management">MDN: Memory Management in JavaScript</a></li>
<li><a href="https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-java/html/page424.html">Mark and Sweep Algorithm</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">Tracing Garbage Collection</a></li>
</ul>
</section>

  
  

  
  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://printf-scanf.pages.dev/posts/storefm1/"
      ><span class="mr-1.5">←</span><span>Working with Go&#39;s Standard Library - StoreFM#1</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://printf-scanf.pages.dev/posts/nodejsprofiling/"
      ><span>Profiling Your Node.js Production Code</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="https://printf-scanf.pages.dev/">Printf/Scanf</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >✎ Paper</a
  >
</footer>

  </body>
</html>
